// DO NOT EDIT! Autogenerated by HLA tool

class SomeId {
    constructor(
        readonly valueSomeId: string
    ) {}

    getValue(): string {
        return this.valueSomeId
    }

    equals(other: SomeId): boolean {
        return this.getValue() === other.getValue()
    }

    toString(): string {
        return this.getValue().toString()
    }
}

class SomeOtherId {
    constructor(
        readonly valueSomeOtherId: string
    ) {}

    getValue(): string {
        return this.valueSomeOtherId
    }

    equals(other: SomeOtherId): boolean {
        return this.getValue() === other.getValue()
    }

    toString(): string {
        return this.getValue().toString()
    }
}

class SomeIntWrapper {
    constructor(
        readonly valueSomeIntWrapper: number
    ) {}

    getValue(): number {
        return this.valueSomeIntWrapper
    }

    equals(other: SomeIntWrapper): boolean {
        return this.getValue() === other.getValue()
    }

    toString(): string {
        return this.getValue().toString()
    }

    plus(other: SomeIntWrapper): SomeIntWrapper {
        return new SomeIntWrapper(this.getValue() + other.getValue());
    }

    minus(other: SomeIntWrapper): SomeIntWrapper {
        return new SomeIntWrapper(this.getValue() - other.getValue());
    }

    times(amount: number): SomeIntWrapper {
        return new SomeIntWrapper(this.getValue() * amount);
    }
}

class SomeId2 {
    constructor(
        readonly valueSomeId2: number
    ) {}

    getValue(): number {
        return this.valueSomeId2
    }

    equals(other: SomeId2): boolean {
        return this.getValue() === other.getValue()
    }

    toString(): string {
        return this.getValue().toString()
    }

    plus(other: SomeId2): SomeId2 {
        return new SomeId2(this.getValue() + other.getValue());
    }

    minus(other: SomeId2): SomeId2 {
        return new SomeId2(this.getValue() - other.getValue());
    }

    times(amount: number): SomeId2 {
        return new SomeId2(this.getValue() * amount);
    }
}

class SomeClass {
    private id = STRING
    private amount = NUMBER

    static create(
        id: SomeId,
        amount: number,
    ): SomeClass {
        const instance = new SomeClass()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    static createNamed({
        id,
        amount,
    }: {
        id: SomeId;
        amount: number;
    }): SomeClass {
        const instance = new SomeClass()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    getId(): SomeId {
        return new SomeId(this.id)
    }

    getAmount(): number {
        return this.amount
    }
}

class SomeClass2 {
    private id = STRING
    private names = [STRING]
    private ids = [STRING]
    private enabled = BOOLEAN

    static create(
        id: SomeId,
        names: string[],
        ids: SomeId[],
        enabled: boolean = true,
    ): SomeClass2 {
        const instance = new SomeClass2()
        instance.id = id.getValue()
        instance.names = names
        instance.ids = ids.map(it => it.getValue())
        instance.enabled = enabled
        return instance
    }

    static createNamed({
        id,
        names,
        ids,
        enabled,
    }: {
        id: SomeId;
        names: string[];
        ids: SomeId[];
        enabled: boolean;
    }): SomeClass2 {
        const instance = new SomeClass2()
        instance.id = id.getValue()
        instance.names = names
        instance.ids = ids.map(it => it.getValue())
        instance.enabled = enabled
        return instance
    }

    getId(): SomeId {
        return new SomeId(this.id)
    }

    getNames(): string[] {
        return this.names
    }

    getIds(): SomeId[] {
        return this.ids.map(it => new SomeId(it))
    }

    getEnabled(): boolean {
        return this.enabled
    }
}

class SomeClass3 {
    private class2Object = Class(SomeClass2)
    private someEnum = STRING
    private class2List = [Class(SomeClass2)]

    static create(
        class2Object: SomeClass2,
        someEnum: SomeEnum,
        class2List: SomeClass2[] = [],
    ): SomeClass3 {
        const instance = new SomeClass3()
        instance.class2Object = class2Object
        instance.someEnum = someEnum.getName()
        instance.class2List = class2List
        return instance
    }

    static createNamed({
        class2Object,
        someEnum,
        class2List,
    }: {
        class2Object: SomeClass2;
        someEnum: SomeEnum;
        class2List: SomeClass2[];
    }): SomeClass3 {
        const instance = new SomeClass3()
        instance.class2Object = class2Object
        instance.someEnum = someEnum.getName()
        instance.class2List = class2List
        return instance
    }

    getClass2Object(): SomeClass2 {
        return this.class2Object
    }

    getSomeEnum(): SomeEnum {
        return SomeEnum.fromName(this.someEnum)
    }

    getClass2List(): SomeClass2[] {
        return this.class2List
    }
}

class SomeClass4 {
    private otherId = NUMBER
    private otherClass = Class(OtherClass)
    private otherIdList = [NUMBER]
    private otherClassList = [Class(OtherClass)]

    static create(
        otherId: OtherId,
        otherClass: OtherClass,
        otherIdList: OtherId[],
        otherClassList: OtherClass[],
    ): SomeClass4 {
        const instance = new SomeClass4()
        instance.otherId = otherId.getValue()
        instance.otherClass = otherClass
        instance.otherIdList = otherIdList.map(it => it.getValue())
        instance.otherClassList = otherClassList
        return instance
    }

    static createNamed({
        otherId,
        otherClass,
        otherIdList,
        otherClassList,
    }: {
        otherId: OtherId;
        otherClass: OtherClass;
        otherIdList: OtherId[];
        otherClassList: OtherClass[];
    }): SomeClass4 {
        const instance = new SomeClass4()
        instance.otherId = otherId.getValue()
        instance.otherClass = otherClass
        instance.otherIdList = otherIdList.map(it => it.getValue())
        instance.otherClassList = otherClassList
        return instance
    }

    getOtherId(): OtherId {
        return new OtherId(this.otherId)
    }

    getOtherClass(): OtherClass {
        return this.otherClass
    }

    getOtherIdList(): OtherId[] {
        return this.otherIdList.map(it => new OtherId(it))
    }

    getOtherClassList(): OtherClass[] {
        return this.otherClassList
    }
}

class SomeClass5 {
    private date = STRING
    private dateRange = Class(SerializedDateRange)
    private dateRangeWrapper = Class(SerializedDateRangeWrapper)
    private someProperty = Class(SomeProperty)
    private otherProperty = Class(OtherProperty)

    static create(
        date: Date,
        dateRange: DateRange,
        dateRangeWrapper: DateRangeWrapper,
        someProperty: SomeProperty,
        otherProperty: OtherProperty,
    ): SomeClass5 {
        const instance = new SomeClass5()
        instance.date = TypesModule.CustomTypesMapper.dateGetValue(date)
        instance.dateRange = SerializedDateRange.fromCustomType(dateRange)
        instance.dateRangeWrapper = SerializedDateRangeWrapper.fromCustomType(dateRangeWrapper)
        instance.someProperty = someProperty
        instance.otherProperty = otherProperty
        return instance
    }

    static createNamed({
        date,
        dateRange,
        dateRangeWrapper,
        someProperty,
        otherProperty,
    }: {
        date: Date;
        dateRange: DateRange;
        dateRangeWrapper: DateRangeWrapper;
        someProperty: SomeProperty;
        otherProperty: OtherProperty;
    }): SomeClass5 {
        const instance = new SomeClass5()
        instance.date = TypesModule.CustomTypesMapper.dateGetValue(date)
        instance.dateRange = SerializedDateRange.fromCustomType(dateRange)
        instance.dateRangeWrapper = SerializedDateRangeWrapper.fromCustomType(dateRangeWrapper)
        instance.someProperty = someProperty
        instance.otherProperty = otherProperty
        return instance
    }

    getDate(): Date {
        return TypesModule.CustomTypesMapper.dateCreate(this.date)
    }

    getDateRange(): DateRange {
        return this.dateRange.toCustomType()
    }

    getDateRangeWrapper(): DateRangeWrapper {
        return this.dateRangeWrapper.toCustomType()
    }

    getSomeProperty(): SomeProperty {
        return this.someProperty
    }

    getOtherProperty(): OtherProperty {
        return this.otherProperty
    }
}

class SomeClass6 {
    private someClassOpt? = OptionalClass(SomeClass)
    private optString? = OPTIONAL_STRING
    private class2List = [Class(SomeClass2)]
    private sameClassList = [Class(SomeClass6)]

    static create(
        someClassOpt: Optional<SomeClass>,
        optString: Optional<string>,
        class2List: SomeClass2[],
        sameClassList: SomeClass6[] = [],
    ): SomeClass6 {
        const instance = new SomeClass6()
        instance.someClassOpt = someClassOpt.orElse(undefined)
        instance.optString = optString.orElse(undefined)
        instance.class2List = class2List
        instance.sameClassList = sameClassList
        return instance
    }

    static createNamed({
        someClassOpt,
        optString,
        class2List,
        sameClassList,
    }: {
        someClassOpt: Optional<SomeClass>;
        optString: Optional<string>;
        class2List: SomeClass2[];
        sameClassList: SomeClass6[];
    }): SomeClass6 {
        const instance = new SomeClass6()
        instance.someClassOpt = someClassOpt.orElse(undefined)
        instance.optString = optString.orElse(undefined)
        instance.class2List = class2List
        instance.sameClassList = sameClassList
        return instance
    }

    getSomeClassOpt(): Optional<SomeClass> {
        return Optional.of(this.someClassOpt)
    }

    getOptString(): Optional<string> {
        return Optional.of(this.optString)
    }

    getClass2List(): SomeClass2[] {
        return this.class2List
    }

    getSameClassList(): SomeClass6[] {
        return this.sameClassList
    }
}

class ClassHavingOptList {
    private optList? = [OptionalClass(SomeClass)]

    static create(
        optList: Optional<SomeClass[]>,
    ): ClassHavingOptList {
        const instance = new ClassHavingOptList()
        instance.optList = optList.orElse(undefined)
        return instance
    }

    static createNamed({
        optList,
    }: {
        optList: Optional<SomeClass[]>;
    }): ClassHavingOptList {
        const instance = new ClassHavingOptList()
        instance.optList = optList.orElse(undefined)
        return instance
    }

    getOptList(): Optional<SomeClass[]> {
        return Optional.of(this.optList)
    }
}

class ClassHavingOptSimpleVo {
    private optSimpleVo? = OPTIONAL_STRING

    static create(
        optSimpleVo: Optional<SomeId>,
    ): ClassHavingOptSimpleVo {
        const instance = new ClassHavingOptSimpleVo()
        instance.optSimpleVo = optSimpleVo.map(it => it.getValue()).orElse(undefined)
        return instance
    }

    static createNamed({
        optSimpleVo,
    }: {
        optSimpleVo: Optional<SomeId>;
    }): ClassHavingOptSimpleVo {
        const instance = new ClassHavingOptSimpleVo()
        instance.optSimpleVo = optSimpleVo.map(it => it.getValue()).orElse(undefined)
        return instance
    }

    getOptSimpleVo(): Optional<SomeId> {
        return Optional.of(this.optSimpleVo).map(it => new SomeId(it))
    }
}

class RecordClass {
    private id = STRING
    private amount = NUMBER

    static create(
        id: SomeId,
        amount: number,
    ): RecordClass {
        const instance = new RecordClass()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    static createNamed({
        id,
        amount,
    }: {
        id: SomeId;
        amount: number;
    }): RecordClass {
        const instance = new RecordClass()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    getId(): SomeId {
        return new SomeId(this.id)
    }

    getAmount(): number {
        return this.amount
    }
}

class ClassWithOptExamples {
    private optInt? = OPTIONAL_NUMBER
    private optIntWrapper? = OPTIONAL_NUMBER

    static create(
        optInt: Optional<number>,
        optIntWrapper: Optional<SomeIntWrapper>,
    ): ClassWithOptExamples {
        const instance = new ClassWithOptExamples()
        instance.optInt = optInt.orElse(undefined)
        instance.optIntWrapper = optIntWrapper.map(it => it.getValue()).orElse(undefined)
        return instance
    }

    static createNamed({
        optInt,
        optIntWrapper,
    }: {
        optInt: Optional<number>;
        optIntWrapper: Optional<SomeIntWrapper>;
    }): ClassWithOptExamples {
        const instance = new ClassWithOptExamples()
        instance.optInt = optInt.orElse(undefined)
        instance.optIntWrapper = optIntWrapper.map(it => it.getValue()).orElse(undefined)
        return instance
    }

    getOptInt(): Optional<number> {
        return Optional.of(this.optInt)
    }

    getOptIntWrapper(): Optional<SomeIntWrapper> {
        return Optional.of(this.optIntWrapper).map(it => new SomeIntWrapper(it))
    }
}

class ClassWithEnumList {
    private enumList = [STRING]

    static create(
        enumList: SomeEnum2[],
    ): ClassWithEnumList {
        const instance = new ClassWithEnumList()
        instance.enumList = enumList.map(it => it.getName())
        return instance
    }

    static createNamed({
        enumList,
    }: {
        enumList: SomeEnum2[];
    }): ClassWithEnumList {
        const instance = new ClassWithEnumList()
        instance.enumList = enumList.map(it => it.getName())
        return instance
    }

    getEnumList(): SomeEnum2[] {
        return this.enumList.map(it => SomeEnum2.fromName(it))
    }
}

class ClassWithBoolField {
    private boolField = BOOLEAN

    static create(
        boolField: boolean,
    ): ClassWithBoolField {
        const instance = new ClassWithBoolField()
        instance.boolField = boolField
        return instance
    }

    static createNamed({
        boolField,
    }: {
        boolField: boolean;
    }): ClassWithBoolField {
        const instance = new ClassWithBoolField()
        instance.boolField = boolField
        return instance
    }

    getBoolField(): boolean {
        return this.boolField
    }
}

class RecursiveClass {
    private meList = [Class(RecursiveClass)]
    private meOpt? = OptionalClass(RecursiveClass)
    private meOptList? = [OptionalClass(RecursiveClass)]

    static create(
        meList: RecursiveClass[],
        meOpt: Optional<RecursiveClass>,
        meOptList: Optional<RecursiveClass[]>,
    ): RecursiveClass {
        const instance = new RecursiveClass()
        instance.meList = meList
        instance.meOpt = meOpt.orElse(undefined)
        instance.meOptList = meOptList.orElse(undefined)
        return instance
    }

    static createNamed({
        meList,
        meOpt,
        meOptList,
    }: {
        meList: RecursiveClass[];
        meOpt: Optional<RecursiveClass>;
        meOptList: Optional<RecursiveClass[]>;
    }): RecursiveClass {
        const instance = new RecursiveClass()
        instance.meList = meList
        instance.meOpt = meOpt.orElse(undefined)
        instance.meOptList = meOptList.orElse(undefined)
        return instance
    }

    getMeList(): RecursiveClass[] {
        return this.meList
    }

    getMeOpt(): Optional<RecursiveClass> {
        return Optional.of(this.meOpt)
    }

    getMeOptList(): Optional<RecursiveClass[]> {
        return Optional.of(this.meOptList)
    }
}

class SomeQueryInput {
    private id = STRING
    private amount = NUMBER

    static create(
        id: SomeId,
        amount: number,
    ): SomeQueryInput {
        const instance = new SomeQueryInput()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    static createNamed({
        id,
        amount,
    }: {
        id: SomeId;
        amount: number;
    }): SomeQueryInput {
        const instance = new SomeQueryInput()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    getId(): SomeId {
        return new SomeId(this.id)
    }

    getAmount(): number {
        return this.amount
    }
}

class SomeHandlerInput {
    private id = STRING
    private amount = NUMBER

    static create(
        id: SomeId,
        amount: number,
    ): SomeHandlerInput {
        const instance = new SomeHandlerInput()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    static createNamed({
        id,
        amount,
    }: {
        id: SomeId;
        amount: number;
    }): SomeHandlerInput {
        const instance = new SomeHandlerInput()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    getId(): SomeId {
        return new SomeId(this.id)
    }

    getAmount(): number {
        return this.amount
    }
}

class SomeHandlerOutput {
    private id = STRING
    private amount = NUMBER

    static create(
        id: SomeId,
        amount: number,
    ): SomeHandlerOutput {
        const instance = new SomeHandlerOutput()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    static createNamed({
        id,
        amount,
    }: {
        id: SomeId;
        amount: number;
    }): SomeHandlerOutput {
        const instance = new SomeHandlerOutput()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    getId(): SomeId {
        return new SomeId(this.id)
    }

    getAmount(): number {
        return this.amount
    }
}

class SomeProperty {
    private other = Class(OtherProperty)
    private id2? = OPTIONAL_NUMBER
    private range? = OptionalClass(SerializedDateRange)
    private doubleExample = NUMBER
    private longExample = NUMBER
    private gN = STRING
    private customData = ANY
    private as = STRING

    static create(
        other: OtherProperty,
        id2: Optional<SomeId2>,
        range: Optional<DateRange>,
        doubleExample: number,
        longExample: number,
        goodName: string,
        customData: any,
        as: string,
    ): SomeProperty {
        const instance = new SomeProperty()
        instance.other = other
        instance.id2 = id2.map(it => it.getValue()).orElse(undefined)
        instance.range = range.map(it => SerializedDateRange.fromCustomType(it)).orElse(undefined)
        instance.doubleExample = doubleExample
        instance.longExample = longExample
        instance.gN = goodName
        instance.customData = customData
        instance.as = as
        return instance
    }

    static createNamed({
        other,
        id2,
        range,
        doubleExample,
        longExample,
        goodName,
        customData,
        as,
    }: {
        other: OtherProperty;
        id2: Optional<SomeId2>;
        range: Optional<DateRange>;
        doubleExample: number;
        longExample: number;
        goodName: string;
        customData: any;
        as: string;
    }): SomeProperty {
        const instance = new SomeProperty()
        instance.other = other
        instance.id2 = id2.map(it => it.getValue()).orElse(undefined)
        instance.range = range.map(it => SerializedDateRange.fromCustomType(it)).orElse(undefined)
        instance.doubleExample = doubleExample
        instance.longExample = longExample
        instance.gN = goodName
        instance.customData = customData
        instance.as = as
        return instance
    }

    getOther(): OtherProperty {
        return this.other
    }

    getId2(): Optional<SomeId2> {
        return Optional.of(this.id2).map(it => new SomeId2(it))
    }

    getRange(): Optional<DateRange> {
        return Optional.of(this.range).map(it => it.toCustomType())
    }

    getDoubleExample(): number {
        return this.doubleExample
    }

    getLongExample(): number {
        return this.longExample
    }

    getGoodName(): string {
        return this.gN
    }

    getCustomData(): any {
        return this.customData
    }

    getAs(): string {
        return this.as
    }
}

class SomeProperty2 {
    value = STRING
    private custom = ANY
    private someEnum = STRING
    private customOpt? = OPTIONAL_ANY
    private as = STRING

    static create(
        value: string,
        custom: any,
        someEnum: SomeEnum,
        customOpt: Optional<any> = Optional.empty(),
        kotlinKeyword: string,
    ): SomeProperty2 {
        const instance = new SomeProperty2()
        instance.value = value
        instance.custom = custom
        instance.someEnum = someEnum.getName()
        instance.customOpt = customOpt.orElse(undefined)
        instance.as = kotlinKeyword
        return instance
    }

    static createNamed({
        value,
        custom,
        someEnum,
        customOpt,
        kotlinKeyword,
    }: {
        value: string;
        custom: any;
        someEnum: SomeEnum;
        customOpt: Optional<any>;
        kotlinKeyword: string;
    }): SomeProperty2 {
        const instance = new SomeProperty2()
        instance.value = value
        instance.custom = custom
        instance.someEnum = someEnum.getName()
        instance.customOpt = customOpt.orElse(undefined)
        instance.as = kotlinKeyword
        return instance
    }

    getValue(): string {
        return this.value
    }

    getCustom(): any {
        return this.custom
    }

    getSomeEnum(): SomeEnum {
        return SomeEnum.fromName(this.someEnum)
    }

    getCustomOpt(): Optional<any> {
        return Optional.of(this.customOpt)
    }

    getKotlinKeyword(): string {
        return this.as
    }
}

class SomePropertyEntry {
    private id = STRING
    private exampleInt = NUMBER
    private exampleLong = NUMBER
    private exampleDouble = NUMBER
    private exampleBool = BOOLEAN
    private exampleString = STRING
    private exampleNumericCustomType = NUMBER
    private exampleNumericCustomType2 = NUMBER
    private exampleVONumeric = NUMBER
    private exampleVONumeric2 = NUMBER

    static create(
        id: SomeId,
        exampleInt: number,
        exampleLong: number,
        exampleDouble: number,
        exampleBool: boolean,
        exampleString: string,
        exampleNumericCustomType: Tier,
        exampleNumericCustomType2: Tier,
        exampleVONumeric: SomeIntWrapper,
        exampleVONumeric2: SomeIntWrapper,
    ): SomePropertyEntry {
        const instance = new SomePropertyEntry()
        instance.id = id.getValue()
        instance.exampleInt = exampleInt
        instance.exampleLong = exampleLong
        instance.exampleDouble = exampleDouble
        instance.exampleBool = exampleBool
        instance.exampleString = exampleString
        instance.exampleNumericCustomType = TypesModule.CustomTypesMapper.tierGetValue(exampleNumericCustomType)
        instance.exampleNumericCustomType2 = TypesModule.CustomTypesMapper.tierGetValue(exampleNumericCustomType2)
        instance.exampleVONumeric = exampleVONumeric.getValue()
        instance.exampleVONumeric2 = exampleVONumeric2.getValue()
        return instance
    }

    static createNamed({
        id,
        exampleInt,
        exampleLong,
        exampleDouble,
        exampleBool,
        exampleString,
        exampleNumericCustomType,
        exampleNumericCustomType2,
        exampleVONumeric,
        exampleVONumeric2,
    }: {
        id: SomeId;
        exampleInt: number;
        exampleLong: number;
        exampleDouble: number;
        exampleBool: boolean;
        exampleString: string;
        exampleNumericCustomType: Tier;
        exampleNumericCustomType2: Tier;
        exampleVONumeric: SomeIntWrapper;
        exampleVONumeric2: SomeIntWrapper;
    }): SomePropertyEntry {
        const instance = new SomePropertyEntry()
        instance.id = id.getValue()
        instance.exampleInt = exampleInt
        instance.exampleLong = exampleLong
        instance.exampleDouble = exampleDouble
        instance.exampleBool = exampleBool
        instance.exampleString = exampleString
        instance.exampleNumericCustomType = TypesModule.CustomTypesMapper.tierGetValue(exampleNumericCustomType)
        instance.exampleNumericCustomType2 = TypesModule.CustomTypesMapper.tierGetValue(exampleNumericCustomType2)
        instance.exampleVONumeric = exampleVONumeric.getValue()
        instance.exampleVONumeric2 = exampleVONumeric2.getValue()
        return instance
    }

    getId(): SomeId {
        return new SomeId(this.id)
    }

    getExampleInt(): number {
        return this.exampleInt
    }

    getExampleLong(): number {
        return this.exampleLong
    }

    getExampleDouble(): number {
        return this.exampleDouble
    }

    getExampleBool(): boolean {
        return this.exampleBool
    }

    getExampleString(): string {
        return this.exampleString
    }

    getExampleNumericCustomType(): Tier {
        return TypesModule.CustomTypesMapper.tierCreate(this.exampleNumericCustomType)
    }

    getExampleNumericCustomType2(): Tier {
        return TypesModule.CustomTypesMapper.tierCreate(this.exampleNumericCustomType2)
    }

    getExampleVONumeric(): SomeIntWrapper {
        return new SomeIntWrapper(this.exampleVONumeric)
    }

    getExampleVONumeric2(): SomeIntWrapper {
        return new SomeIntWrapper(this.exampleVONumeric2)
    }
}

class SomeRenamedSourcePropertyEntry {
    private sId = STRING

    static create(
        id: SomeOtherId,
    ): SomeRenamedSourcePropertyEntry {
        const instance = new SomeRenamedSourcePropertyEntry()
        instance.sId = id.getValue()
        return instance
    }

    static createNamed({
        id,
    }: {
        id: SomeOtherId;
    }): SomeRenamedSourcePropertyEntry {
        const instance = new SomeRenamedSourcePropertyEntry()
        instance.sId = id.getValue()
        return instance
    }

    getId(): SomeOtherId {
        return new SomeOtherId(this.sId)
    }
}

class SomeReferencingProperty {
    private referenceId = STRING

    static create(
        referenceId: SomeId,
    ): SomeReferencingProperty {
        const instance = new SomeReferencingProperty()
        instance.referenceId = referenceId.getValue()
        return instance
    }

    static createNamed({
        referenceId,
    }: {
        referenceId: SomeId;
    }): SomeReferencingProperty {
        const instance = new SomeReferencingProperty()
        instance.referenceId = referenceId.getValue()
        return instance
    }

    getReferenceId(): SomeId {
        return new SomeId(this.referenceId)
    }
}

class SomeRenamedReferencingProperty {
    private rId = STRING

    static create(
        referenceId: SomeId,
    ): SomeRenamedReferencingProperty {
        const instance = new SomeRenamedReferencingProperty()
        instance.rId = referenceId.getValue()
        return instance
    }

    static createNamed({
        referenceId,
    }: {
        referenceId: SomeId;
    }): SomeRenamedReferencingProperty {
        const instance = new SomeRenamedReferencingProperty()
        instance.rId = referenceId.getValue()
        return instance
    }

    getReferenceId(): SomeId {
        return new SomeId(this.rId)
    }
}

class SomeRenamedReferencingRenamedProperty {
    private rId = STRING

    static create(
        referenceId: SomeOtherId,
    ): SomeRenamedReferencingRenamedProperty {
        const instance = new SomeRenamedReferencingRenamedProperty()
        instance.rId = referenceId.getValue()
        return instance
    }

    static createNamed({
        referenceId,
    }: {
        referenceId: SomeOtherId;
    }): SomeRenamedReferencingRenamedProperty {
        const instance = new SomeRenamedReferencingRenamedProperty()
        instance.rId = referenceId.getValue()
        return instance
    }

    getReferenceId(): SomeOtherId {
        return new SomeOtherId(this.rId)
    }
}

class SomeReferencingPropertyFieldList {
    private referenceIdList = [STRING]

    static create(
        referenceIdList: SomeId[],
    ): SomeReferencingPropertyFieldList {
        const instance = new SomeReferencingPropertyFieldList()
        instance.referenceIdList = referenceIdList.map(it => it.getValue())
        return instance
    }

    static createNamed({
        referenceIdList,
    }: {
        referenceIdList: SomeId[];
    }): SomeReferencingPropertyFieldList {
        const instance = new SomeReferencingPropertyFieldList()
        instance.referenceIdList = referenceIdList.map(it => it.getValue())
        return instance
    }

    getReferenceIdList(): SomeId[] {
        return this.referenceIdList.map(it => new SomeId(it))
    }
}

class SomeStructureWithUniqueIds {
    private entries = [Class(UniqueIdEntry)]

    static create(
        entries: UniqueIdEntry[],
    ): SomeStructureWithUniqueIds {
        const instance = new SomeStructureWithUniqueIds()
        instance.entries = entries
        return instance
    }

    static createNamed({
        entries,
    }: {
        entries: UniqueIdEntry[];
    }): SomeStructureWithUniqueIds {
        const instance = new SomeStructureWithUniqueIds()
        instance.entries = entries
        return instance
    }

    getEntries(): UniqueIdEntry[] {
        return this.entries
    }
}

class NestedUniqueIds {
    private entries = [Class(UniqueIdEntry)]

    static create(
        entries: UniqueIdEntry[],
    ): NestedUniqueIds {
        const instance = new NestedUniqueIds()
        instance.entries = entries
        return instance
    }

    static createNamed({
        entries,
    }: {
        entries: UniqueIdEntry[];
    }): NestedUniqueIds {
        const instance = new NestedUniqueIds()
        instance.entries = entries
        return instance
    }

    getEntries(): UniqueIdEntry[] {
        return this.entries
    }
}

class SomeStructureWithUniqueNestedIds {
    private nestedUniqueIds = [Class(NestedUniqueIds)]

    static create(
        nestedUniqueIds: NestedUniqueIds[],
    ): SomeStructureWithUniqueNestedIds {
        const instance = new SomeStructureWithUniqueNestedIds()
        instance.nestedUniqueIds = nestedUniqueIds
        return instance
    }

    static createNamed({
        nestedUniqueIds,
    }: {
        nestedUniqueIds: NestedUniqueIds[];
    }): SomeStructureWithUniqueNestedIds {
        const instance = new SomeStructureWithUniqueNestedIds()
        instance.nestedUniqueIds = nestedUniqueIds
        return instance
    }

    getNestedUniqueIds(): NestedUniqueIds[] {
        return this.nestedUniqueIds
    }
}

class SomeStructureWithMultipleUniqueNestedIds {
    private moreNestedFields = [Class(SomeStructureWithUniqueNestedIds)]

    static create(
        moreNestedFields: SomeStructureWithUniqueNestedIds[],
    ): SomeStructureWithMultipleUniqueNestedIds {
        const instance = new SomeStructureWithMultipleUniqueNestedIds()
        instance.moreNestedFields = moreNestedFields
        return instance
    }

    static createNamed({
        moreNestedFields,
    }: {
        moreNestedFields: SomeStructureWithUniqueNestedIds[];
    }): SomeStructureWithMultipleUniqueNestedIds {
        const instance = new SomeStructureWithMultipleUniqueNestedIds()
        instance.moreNestedFields = moreNestedFields
        return instance
    }

    getMoreNestedFields(): SomeStructureWithUniqueNestedIds[] {
        return this.moreNestedFields
    }
}

class SomeClassWIthOtherClassUniqueIds {
    private otherClass = Class(OtherClassWIthUniqueId)

    static create(
        otherClass: OtherClassWIthUniqueId,
    ): SomeClassWIthOtherClassUniqueIds {
        const instance = new SomeClassWIthOtherClassUniqueIds()
        instance.otherClass = otherClass
        return instance
    }

    static createNamed({
        otherClass,
    }: {
        otherClass: OtherClassWIthUniqueId;
    }): SomeClassWIthOtherClassUniqueIds {
        const instance = new SomeClassWIthOtherClassUniqueIds()
        instance.otherClass = otherClass
        return instance
    }

    getOtherClass(): OtherClassWIthUniqueId {
        return this.otherClass
    }
}

class SomeStructWithNestedOtherClassUniqueIds {
    private someNestedWithUniqueIds = [Class(SomeClassWIthOtherClassUniqueIds)]

    static create(
        someNestedWithUniqueIds: SomeClassWIthOtherClassUniqueIds[],
    ): SomeStructWithNestedOtherClassUniqueIds {
        const instance = new SomeStructWithNestedOtherClassUniqueIds()
        instance.someNestedWithUniqueIds = someNestedWithUniqueIds
        return instance
    }

    static createNamed({
        someNestedWithUniqueIds,
    }: {
        someNestedWithUniqueIds: SomeClassWIthOtherClassUniqueIds[];
    }): SomeStructWithNestedOtherClassUniqueIds {
        const instance = new SomeStructWithNestedOtherClassUniqueIds()
        instance.someNestedWithUniqueIds = someNestedWithUniqueIds
        return instance
    }

    getSomeNestedWithUniqueIds(): SomeClassWIthOtherClassUniqueIds[] {
        return this.someNestedWithUniqueIds
    }
}

class NestedClassLevel2 {
    private uniqueIds = [Class(OtherClassWIthUniqueId)]

    static create(
        uniqueIds: OtherClassWIthUniqueId[],
    ): NestedClassLevel2 {
        const instance = new NestedClassLevel2()
        instance.uniqueIds = uniqueIds
        return instance
    }

    static createNamed({
        uniqueIds,
    }: {
        uniqueIds: OtherClassWIthUniqueId[];
    }): NestedClassLevel2 {
        const instance = new NestedClassLevel2()
        instance.uniqueIds = uniqueIds
        return instance
    }

    getUniqueIds(): OtherClassWIthUniqueId[] {
        return this.uniqueIds
    }
}

class NestedClassLevel1 {
    private nestLevel2 = [Class(NestedClassLevel2)]

    static create(
        nestLevel2: NestedClassLevel2[],
    ): NestedClassLevel1 {
        const instance = new NestedClassLevel1()
        instance.nestLevel2 = nestLevel2
        return instance
    }

    static createNamed({
        nestLevel2,
    }: {
        nestLevel2: NestedClassLevel2[];
    }): NestedClassLevel1 {
        const instance = new NestedClassLevel1()
        instance.nestLevel2 = nestLevel2
        return instance
    }

    getNestLevel2(): NestedClassLevel2[] {
        return this.nestLevel2
    }
}

class ComplexStructureWithNestedUniqueIds {
    private id = STRING
    private nestLevel1 = [Class(NestedClassLevel1)]

    static create(
        id: string,
        nestLevel1: NestedClassLevel1[],
    ): ComplexStructureWithNestedUniqueIds {
        const instance = new ComplexStructureWithNestedUniqueIds()
        instance.id = id
        instance.nestLevel1 = nestLevel1
        return instance
    }

    static createNamed({
        id,
        nestLevel1,
    }: {
        id: string;
        nestLevel1: NestedClassLevel1[];
    }): ComplexStructureWithNestedUniqueIds {
        const instance = new ComplexStructureWithNestedUniqueIds()
        instance.id = id
        instance.nestLevel1 = nestLevel1
        return instance
    }

    getId(): string {
        return this.id
    }

    getNestLevel1(): NestedClassLevel1[] {
        return this.nestLevel1
    }
}

class NestedValue {
    private value = STRING

    static create(
        value: string,
    ): NestedValue {
        const instance = new NestedValue()
        instance.value = value
        return instance
    }

    static createNamed({
        value,
    }: {
        value: string;
    }): NestedValue {
        const instance = new NestedValue()
        instance.value = value
        return instance
    }

    getValue(): string {
        return this.value
    }
}

class OptionalFieldProperty {
    private optionalField? = OptionalClass(NestedValue)

    static create(
        optionalField: Optional<NestedValue>,
    ): OptionalFieldProperty {
        const instance = new OptionalFieldProperty()
        instance.optionalField = optionalField.orElse(undefined)
        return instance
    }

    static createNamed({
        optionalField,
    }: {
        optionalField: Optional<NestedValue>;
    }): OptionalFieldProperty {
        const instance = new OptionalFieldProperty()
        instance.optionalField = optionalField.orElse(undefined)
        return instance
    }

    getOptionalField(): Optional<NestedValue> {
        return Optional.of(this.optionalField)
    }
}

class CustomTypesProperty {
    private date = STRING
    private dateRange = Class(SerializedDateRange)

    static create(
        date: Date,
        dateRange: DateRange,
    ): CustomTypesProperty {
        const instance = new CustomTypesProperty()
        instance.date = TypesModule.CustomTypesMapper.dateGetValue(date)
        instance.dateRange = SerializedDateRange.fromCustomType(dateRange)
        return instance
    }

    static createNamed({
        date,
        dateRange,
    }: {
        date: Date;
        dateRange: DateRange;
    }): CustomTypesProperty {
        const instance = new CustomTypesProperty()
        instance.date = TypesModule.CustomTypesMapper.dateGetValue(date)
        instance.dateRange = SerializedDateRange.fromCustomType(dateRange)
        return instance
    }

    getDate(): Date {
        return TypesModule.CustomTypesMapper.dateCreate(this.date)
    }

    getDateRange(): DateRange {
        return this.dateRange.toCustomType()
    }
}

class SelfReferencingProperty {
    private optionalSelf? = OptionalClass(SelfReferencingProperty)
    private listSelf = [Class(SelfReferencingProperty)]
    private optionalListSelf? = [OptionalClass(SelfReferencingProperty)]

    static create(
        optionalSelf: Optional<SelfReferencingProperty>,
        listSelf: SelfReferencingProperty[],
        optionalListSelf: Optional<SelfReferencingProperty[]>,
    ): SelfReferencingProperty {
        const instance = new SelfReferencingProperty()
        instance.optionalSelf = optionalSelf.orElse(undefined)
        instance.listSelf = listSelf
        instance.optionalListSelf = optionalListSelf.orElse(undefined)
        return instance
    }

    static createNamed({
        optionalSelf,
        listSelf,
        optionalListSelf,
    }: {
        optionalSelf: Optional<SelfReferencingProperty>;
        listSelf: SelfReferencingProperty[];
        optionalListSelf: Optional<SelfReferencingProperty[]>;
    }): SelfReferencingProperty {
        const instance = new SelfReferencingProperty()
        instance.optionalSelf = optionalSelf.orElse(undefined)
        instance.listSelf = listSelf
        instance.optionalListSelf = optionalListSelf.orElse(undefined)
        return instance
    }

    getOptionalSelf(): Optional<SelfReferencingProperty> {
        return Optional.of(this.optionalSelf)
    }

    getListSelf(): SelfReferencingProperty[] {
        return this.listSelf
    }

    getOptionalListSelf(): Optional<SelfReferencingProperty[]> {
        return Optional.of(this.optionalListSelf)
    }
}

class CustomTypesPropertyOptionalList {
    private id = STRING
    private customPropertiesList? = [OptionalClass(CustomTypesProperty)]

    static create(
        id: string,
        customPropertiesList: Optional<CustomTypesProperty[]>,
    ): CustomTypesPropertyOptionalList {
        const instance = new CustomTypesPropertyOptionalList()
        instance.id = id
        instance.customPropertiesList = customPropertiesList.orElse(undefined)
        return instance
    }

    static createNamed({
        id,
        customPropertiesList,
    }: {
        id: string;
        customPropertiesList: Optional<CustomTypesProperty[]>;
    }): CustomTypesPropertyOptionalList {
        const instance = new CustomTypesPropertyOptionalList()
        instance.id = id
        instance.customPropertiesList = customPropertiesList.orElse(undefined)
        return instance
    }

    getId(): string {
        return this.id
    }

    getCustomPropertiesList(): Optional<CustomTypesProperty[]> {
        return Optional.of(this.customPropertiesList)
    }
}

class SomeInterfaceSomeCommandArgs {
    private id = STRING
    private amount = NUMBER

    static create(
        id: SomeId,
        amount: number,
    ): SomeInterfaceSomeCommandArgs {
        const instance = new SomeInterfaceSomeCommandArgs()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    static createNamed({
        id,
        amount,
    }: {
        id: SomeId;
        amount: number;
    }): SomeInterfaceSomeCommandArgs {
        const instance = new SomeInterfaceSomeCommandArgs()
        instance.id = id.getValue()
        instance.amount = amount
        return instance
    }

    getId(): SomeId {
        return new SomeId(this.id)
    }

    getAmount(): number {
        return this.amount
    }
}