// DO NOT EDIT! Autogenerated by HLA tool

namespace SomeModule {
    class SomeInterface2Mock implements SomeInterface2 {
        // referenceOtherClass
        private readonly referenceOtherClassCalls: OtherClass[] = []
        private readonly referenceOtherClassResponses: Pair<ExpectedOtherClass.() -> Unit, OtherClassDef.() -> Unit>[] = []

        fun setReferenceOtherClassResponse(args: ExpectedOtherClass.() -> Unit, response: OtherClassDef.() -> Unit) {
            referenceOtherClassResponses.add(Pair(args, response))
        }

        override fun referenceOtherClass(other: OtherClass): OtherClass {
            referenceOtherClassCalls.add(other)
            return otherClass(referenceOtherClassResponses.find { diffOtherClass(other, it.first) == "" }?.second ?: {})
        }

        fun assertReferenceOtherClassCalled(times: Int = 1) {
            assertThat(referenceOtherClassCalls.size).withFailMessage("Expected referenceOtherClass to be called $times times, but was called $referenceOtherClassCalls times").isEqualTo(times)
        }

        fun assertReferenceOtherClassCalledForArgs(args: ExpectedOtherClass.() -> Unit, times: Int = 1) {
            val calls = referenceOtherClassCalls.filter { diffOtherClass(it, args) == "" }
            assertThat(calls.size).withFailMessage("Expected referenceOtherClass to be called $times times, but was called $referenceOtherClassCalls times").isEqualTo(times)
        }

        // referenceLegacyType
        private readonly referenceLegacyTypeCalls: LegacyType[] = []
        private readonly referenceLegacyTypeResponses: Pair<LegacyType, LegacyType>[] = []

        fun setReferenceLegacyTypeResponse(args: LegacyType, response: LegacyType) {
            referenceLegacyTypeResponses.add(Pair(args, response))
        }

        override fun referenceLegacyType(legacyType: LegacyType): LegacyType {
            referenceLegacyTypeCalls.add(legacyType)
            return legacyType(referenceLegacyTypeResponses.find { diffLegacyType(legacyType, it.first) == "" }?.second ?: null)
        }

        fun assertReferenceLegacyTypeCalled(times: Int = 1) {
            assertThat(referenceLegacyTypeCalls.size).withFailMessage("Expected referenceLegacyType to be called $times times, but was called $referenceLegacyTypeCalls times").isEqualTo(times)
        }

        fun assertReferenceLegacyTypeCalledForArgs(args: LegacyType, times: Int = 1) {
            val calls = referenceLegacyTypeCalls.filter { diffLegacyType(it, args) == "" }
            assertThat(calls.size).withFailMessage("Expected referenceLegacyType to be called $times times, but was called $referenceLegacyTypeCalls times").isEqualTo(times)
        }
    }
}