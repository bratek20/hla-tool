// DO NOT EDIT! Autogenerated by HLA tool

package com.github.bratek20.hla.definitions.fixtures

import com.github.bratek20.hla.facade.api.*
import com.github.bratek20.hla.facade.fixtures.*

import com.github.bratek20.hla.definitions.api.*

data class KeyDefinitionDef(
    var name: String = "someValue",
    var type: (TypeDefinitionDef.() -> Unit) = {},
)
fun keyDefinition(init: KeyDefinitionDef.() -> Unit = {}): KeyDefinition {
    val def = KeyDefinitionDef().apply(init)
    return KeyDefinition.create(
        name = def.name,
        type = typeDefinition(def.type),
    )
}

data class EnumDefinitionDef(
    var name: String = "someValue",
    var values: List<String> = emptyList(),
)
fun enumDefinition(init: EnumDefinitionDef.() -> Unit = {}): EnumDefinition {
    val def = EnumDefinitionDef().apply(init)
    return EnumDefinition.create(
        name = def.name,
        values = def.values,
    )
}

data class ImplSubmoduleDefinitionDef(
    var dataClasses: List<(ComplexStructureDefinitionDef.() -> Unit)> = emptyList(),
    var dataKeys: List<(KeyDefinitionDef.() -> Unit)> = emptyList(),
)
fun implSubmoduleDefinition(init: ImplSubmoduleDefinitionDef.() -> Unit = {}): ImplSubmoduleDefinition {
    val def = ImplSubmoduleDefinitionDef().apply(init)
    return ImplSubmoduleDefinition.create(
        dataClasses = def.dataClasses.map { it -> complexStructureDefinition(it) },
        dataKeys = def.dataKeys.map { it -> keyDefinition(it) },
    )
}

data class WebSubmoduleDefinitionDef(
    var expose: List<String> = emptyList(),
    var serverUrl: String? = null,
)
fun webSubmoduleDefinition(init: WebSubmoduleDefinitionDef.() -> Unit = {}): WebSubmoduleDefinition {
    val def = WebSubmoduleDefinitionDef().apply(init)
    return WebSubmoduleDefinition.create(
        expose = def.expose,
        serverUrl = def.serverUrl,
    )
}

data class ExternalTypePackageMappingDef(
    var name: String = "someValue",
    var packageName: String = "someValue",
)
fun externalTypePackageMapping(init: ExternalTypePackageMappingDef.() -> Unit = {}): ExternalTypePackageMapping {
    val def = ExternalTypePackageMappingDef().apply(init)
    return ExternalTypePackageMapping.create(
        name = def.name,
        packageName = def.packageName,
    )
}

data class KotlinConfigDef(
    var externalTypePackages: List<(ExternalTypePackageMappingDef.() -> Unit)> = emptyList(),
    var records: List<String> = emptyList(),
)
fun kotlinConfig(init: KotlinConfigDef.() -> Unit = {}): KotlinConfig {
    val def = KotlinConfigDef().apply(init)
    return KotlinConfig.create(
        externalTypePackages = def.externalTypePackages.map { it -> externalTypePackageMapping(it) },
        records = def.records,
    )
}

data class ModuleDefinitionDef(
    var name: String = "someValue",
    var simpleCustomTypes: List<(SimpleStructureDefinitionDef.() -> Unit)> = emptyList(),
    var complexCustomTypes: List<(ComplexStructureDefinitionDef.() -> Unit)> = emptyList(),
    var simpleValueObjects: List<(SimpleStructureDefinitionDef.() -> Unit)> = emptyList(),
    var complexValueObjects: List<(ComplexStructureDefinitionDef.() -> Unit)> = emptyList(),
    var dataClasses: List<(ComplexStructureDefinitionDef.() -> Unit)> = emptyList(),
    var interfaces: List<(InterfaceDefinitionDef.() -> Unit)> = emptyList(),
    var propertyKeys: List<(KeyDefinitionDef.() -> Unit)> = emptyList(),
    var dataKeys: List<(KeyDefinitionDef.() -> Unit)> = emptyList(),
    var enums: List<(EnumDefinitionDef.() -> Unit)> = emptyList(),
    var externalTypes: List<String> = emptyList(),
    var implSubmodule: (ImplSubmoduleDefinitionDef.() -> Unit)? = null,
    var webSubmodule: (WebSubmoduleDefinitionDef.() -> Unit)? = null,
    var kotlinConfig: (KotlinConfigDef.() -> Unit)? = null,
)
fun moduleDefinition(init: ModuleDefinitionDef.() -> Unit = {}): ModuleDefinition {
    val def = ModuleDefinitionDef().apply(init)
    return ModuleDefinition.create(
        name = ModuleName(def.name),
        simpleCustomTypes = def.simpleCustomTypes.map { it -> simpleStructureDefinition(it) },
        complexCustomTypes = def.complexCustomTypes.map { it -> complexStructureDefinition(it) },
        simpleValueObjects = def.simpleValueObjects.map { it -> simpleStructureDefinition(it) },
        complexValueObjects = def.complexValueObjects.map { it -> complexStructureDefinition(it) },
        dataClasses = def.dataClasses.map { it -> complexStructureDefinition(it) },
        interfaces = def.interfaces.map { it -> interfaceDefinition(it) },
        propertyKeys = def.propertyKeys.map { it -> keyDefinition(it) },
        dataKeys = def.dataKeys.map { it -> keyDefinition(it) },
        enums = def.enums.map { it -> enumDefinition(it) },
        externalTypes = def.externalTypes,
        implSubmodule = def.implSubmodule?.let { it -> implSubmoduleDefinition(it) },
        webSubmodule = def.webSubmodule?.let { it -> webSubmoduleDefinition(it) },
        kotlinConfig = def.kotlinConfig?.let { it -> kotlinConfig(it) },
    )
}

data class TypeDefinitionDef(
    var name: String = "someValue",
    var wrappers: List<String> = emptyList(),
)
fun typeDefinition(init: TypeDefinitionDef.() -> Unit = {}): TypeDefinition {
    val def = TypeDefinitionDef().apply(init)
    return TypeDefinition.create(
        name = def.name,
        wrappers = def.wrappers.map { it -> TypeWrapper.valueOf(it) },
    )
}

data class FieldDefinitionDef(
    var name: String = "someValue",
    var type: (TypeDefinitionDef.() -> Unit) = {},
    var attributes: List<(AttributeDef.() -> Unit)> = emptyList(),
    var defaultValue: String? = null,
)
fun fieldDefinition(init: FieldDefinitionDef.() -> Unit = {}): FieldDefinition {
    val def = FieldDefinitionDef().apply(init)
    return FieldDefinition.create(
        name = def.name,
        type = typeDefinition(def.type),
        attributes = def.attributes.map { it -> attribute(it) },
        defaultValue = def.defaultValue,
    )
}

data class AttributeDef(
    var name: String = "someValue",
    var value: String = "someValue",
)
fun attribute(init: AttributeDef.() -> Unit = {}): Attribute {
    val def = AttributeDef().apply(init)
    return Attribute.create(
        name = def.name,
        value = def.value,
    )
}

data class SimpleStructureDefinitionDef(
    var name: String = "someValue",
    var typeName: String = "someValue",
    var attributes: List<(AttributeDef.() -> Unit)> = emptyList(),
)
fun simpleStructureDefinition(init: SimpleStructureDefinitionDef.() -> Unit = {}): SimpleStructureDefinition {
    val def = SimpleStructureDefinitionDef().apply(init)
    return SimpleStructureDefinition.create(
        name = def.name,
        typeName = def.typeName,
        attributes = def.attributes.map { it -> attribute(it) },
    )
}

data class ComplexStructureDefinitionDef(
    var name: String = "someValue",
    var fields: List<(FieldDefinitionDef.() -> Unit)> = emptyList(),
)
fun complexStructureDefinition(init: ComplexStructureDefinitionDef.() -> Unit = {}): ComplexStructureDefinition {
    val def = ComplexStructureDefinitionDef().apply(init)
    return ComplexStructureDefinition.create(
        name = def.name,
        fields = def.fields.map { it -> fieldDefinition(it) },
    )
}

data class InterfaceDefinitionDef(
    var name: String = "someValue",
    var methods: List<(MethodDefinitionDef.() -> Unit)> = emptyList(),
)
fun interfaceDefinition(init: InterfaceDefinitionDef.() -> Unit = {}): InterfaceDefinition {
    val def = InterfaceDefinitionDef().apply(init)
    return InterfaceDefinition.create(
        name = def.name,
        methods = def.methods.map { it -> methodDefinition(it) },
    )
}

data class ArgumentDefinitionDef(
    var name: String = "someValue",
    var type: (TypeDefinitionDef.() -> Unit) = {},
)
fun argumentDefinition(init: ArgumentDefinitionDef.() -> Unit = {}): ArgumentDefinition {
    val def = ArgumentDefinitionDef().apply(init)
    return ArgumentDefinition.create(
        name = def.name,
        type = typeDefinition(def.type),
    )
}

data class ExceptionDefinitionDef(
    var name: String = "someValue",
)
fun exceptionDefinition(init: ExceptionDefinitionDef.() -> Unit = {}): ExceptionDefinition {
    val def = ExceptionDefinitionDef().apply(init)
    return ExceptionDefinition.create(
        name = def.name,
    )
}

data class MethodDefinitionDef(
    var name: String = "someValue",
    var returnType: (TypeDefinitionDef.() -> Unit) = {},
    var args: List<(ArgumentDefinitionDef.() -> Unit)> = emptyList(),
    var throws: List<(ExceptionDefinitionDef.() -> Unit)> = emptyList(),
)
fun methodDefinition(init: MethodDefinitionDef.() -> Unit = {}): MethodDefinition {
    val def = MethodDefinitionDef().apply(init)
    return MethodDefinition.create(
        name = def.name,
        returnType = typeDefinition(def.returnType),
        args = def.args.map { it -> argumentDefinition(it) },
        throws = def.throws.map { it -> exceptionDefinition(it) },
    )
}