// DO NOT EDIT! Autogenerated by HLA tool

package com.github.bratek20.hla.tracking.fixtures

import com.github.bratek20.hla.definitions.api.*
import com.github.bratek20.hla.definitions.fixtures.*

import com.github.bratek20.hla.tracking.api.*

data class ExpectedTableDefinition(
    var name: String? = null,
    var attributes: List<(ExpectedAttribute.() -> Unit)>? = null,
    var exposedClasses: List<(ExpectedDependentConceptDefinition.() -> Unit)>? = null,
    var fields: List<(ExpectedFieldDefinition.() -> Unit)>? = null,
)
fun diffTableDefinition(given: TableDefinition, expectedInit: ExpectedTableDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedTableDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.getName() != it) { result.add("${path}name ${given.getName()} != ${it}") }
    }

    expected.attributes?.let {
        if (given.getAttributes().size != it.size) { result.add("${path}attributes size ${given.getAttributes().size} != ${it.size}"); return@let }
        given.getAttributes().forEachIndexed { idx, entry -> if (diffAttribute(entry, it[idx]) != "") { result.add(diffAttribute(entry, it[idx], "${path}attributes[${idx}].")) } }
    }

    expected.exposedClasses?.let {
        if (given.getExposedClasses().size != it.size) { result.add("${path}exposedClasses size ${given.getExposedClasses().size} != ${it.size}"); return@let }
        given.getExposedClasses().forEachIndexed { idx, entry -> if (diffDependentConceptDefinition(entry, it[idx]) != "") { result.add(diffDependentConceptDefinition(entry, it[idx], "${path}exposedClasses[${idx}].")) } }
    }

    expected.fields?.let {
        if (given.getFields().size != it.size) { result.add("${path}fields size ${given.getFields().size} != ${it.size}"); return@let }
        given.getFields().forEachIndexed { idx, entry -> if (diffFieldDefinition(entry, it[idx]) != "") { result.add(diffFieldDefinition(entry, it[idx], "${path}fields[${idx}].")) } }
    }

    return result.joinToString("\n")
}

data class ExpectedTrackingSubmoduleDefinition(
    var attributes: List<(ExpectedAttribute.() -> Unit)>? = null,
    var dimensions: (ExpectedTableDefinition.() -> Unit)? = null,
    var events: (ExpectedTableDefinition.() -> Unit)? = null,
)
fun diffTrackingSubmoduleDefinition(given: TrackingSubmoduleDefinition, expectedInit: ExpectedTrackingSubmoduleDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedTrackingSubmoduleDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.attributes?.let {
        if (given.getAttributes().size != it.size) { result.add("${path}attributes size ${given.getAttributes().size} != ${it.size}"); return@let }
        given.getAttributes().forEachIndexed { idx, entry -> if (diffAttribute(entry, it[idx]) != "") { result.add(diffAttribute(entry, it[idx], "${path}attributes[${idx}].")) } }
    }

    expected.dimensions?.let {
        if (diffTableDefinition(given.getDimensions(), it) != "") { result.add(diffTableDefinition(given.getDimensions(), it, "${path}dimensions.")) }
    }

    expected.events?.let {
        if (diffTableDefinition(given.getEvents(), it) != "") { result.add(diffTableDefinition(given.getEvents(), it, "${path}events.")) }
    }

    return result.joinToString("\n")
}