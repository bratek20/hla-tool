// DO NOT EDIT! Autogenerated by HLA tool

package com.github.bratek20.hla.generation.fixtures

import com.github.bratek20.utils.directory.api.*
import com.github.bratek20.utils.directory.fixtures.*
import com.github.bratek20.hla.facade.api.*
import com.github.bratek20.hla.facade.fixtures.*
import com.github.bratek20.hla.parsing.api.*
import com.github.bratek20.hla.parsing.fixtures.*

import com.github.bratek20.hla.generation.api.*

fun diffSubmoduleName(given: SubmoduleName, expected: String, path: String = ""): String {
    if (given != SubmoduleName.valueOf(expected)) { return "${path}value ${given.name} != ${expected}" }
    return ""
}

fun diffPatternName(given: PatternName, expected: String, path: String = ""): String {
    if (given != PatternName.valueOf(expected)) { return "${path}value ${given.name} != ${expected}" }
    return ""
}

data class ExpectedGeneratedPattern(
    var name: String? = null,
    var fileEmpty: Boolean? = null,
    var file: (ExpectedFile.() -> Unit)? = null,
    var directoryEmpty: Boolean? = null,
    var directory: (ExpectedDirectory.() -> Unit)? = null,
)
fun diffGeneratedPattern(given: GeneratedPattern, expectedInit: ExpectedGeneratedPattern.() -> Unit, path: String = ""): String {
    val expected = ExpectedGeneratedPattern().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (diffPatternName(given.getName(), it) != "") { result.add(diffPatternName(given.getName(), it, "${path}name.")) }
    }

    expected.fileEmpty?.let {
        if ((given.getFile() == null) != it) { result.add("${path}file empty ${(given.getFile() == null)} != ${it}") }
    }

    expected.file?.let {
        if (diffFile(given.getFile()!!, it) != "") { result.add(diffFile(given.getFile()!!, it, "${path}file.")) }
    }

    expected.directoryEmpty?.let {
        if ((given.getDirectory() == null) != it) { result.add("${path}directory empty ${(given.getDirectory() == null)} != ${it}") }
    }

    expected.directory?.let {
        if (diffDirectory(given.getDirectory()!!, it) != "") { result.add(diffDirectory(given.getDirectory()!!, it, "${path}directory.")) }
    }

    return result.joinToString("\n")
}

data class ExpectedGeneratedSubmodule(
    var name: String? = null,
    var patterns: List<(ExpectedGeneratedPattern.() -> Unit)>? = null,
)
fun diffGeneratedSubmodule(given: GeneratedSubmodule, expectedInit: ExpectedGeneratedSubmodule.() -> Unit, path: String = ""): String {
    val expected = ExpectedGeneratedSubmodule().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (diffSubmoduleName(given.getName(), it) != "") { result.add(diffSubmoduleName(given.getName(), it, "${path}name.")) }
    }

    expected.patterns?.let {
        if (given.getPatterns().size != it.size) { result.add("${path}patterns size ${given.getPatterns().size} != ${it.size}"); return@let }
        given.getPatterns().forEachIndexed { idx, entry -> if (diffGeneratedPattern(entry, it[idx]) != "") { result.add(diffGeneratedPattern(entry, it[idx], "${path}patterns[${idx}].")) } }
    }

    return result.joinToString("\n")
}

data class ExpectedGeneratedModule(
    var name: String? = null,
    var submodules: List<(ExpectedGeneratedSubmodule.() -> Unit)>? = null,
)
fun diffGeneratedModule(given: GeneratedModule, expectedInit: ExpectedGeneratedModule.() -> Unit, path: String = ""): String {
    val expected = ExpectedGeneratedModule().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (diffModuleName(given.getName(), it) != "") { result.add(diffModuleName(given.getName(), it, "${path}name.")) }
    }

    expected.submodules?.let {
        if (given.getSubmodules().size != it.size) { result.add("${path}submodules size ${given.getSubmodules().size} != ${it.size}"); return@let }
        given.getSubmodules().forEachIndexed { idx, entry -> if (diffGeneratedSubmodule(entry, it[idx]) != "") { result.add(diffGeneratedSubmodule(entry, it[idx], "${path}submodules[${idx}].")) } }
    }

    return result.joinToString("\n")
}

data class ExpectedGenerateArgs(
    var group: (ExpectedModuleGroup.() -> Unit)? = null,
    var moduleToGenerate: String? = null,
    var onlyUpdate: Boolean? = null,
)
fun diffGenerateArgs(given: GenerateArgs, expectedInit: ExpectedGenerateArgs.() -> Unit, path: String = ""): String {
    val expected = ExpectedGenerateArgs().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.group?.let {
        if (diffModuleGroup(given.getGroup(), it) != "") { result.add(diffModuleGroup(given.getGroup(), it, "${path}group.")) }
    }

    expected.moduleToGenerate?.let {
        if (diffModuleName(given.getModuleToGenerate(), it) != "") { result.add(diffModuleName(given.getModuleToGenerate(), it, "${path}moduleToGenerate.")) }
    }

    expected.onlyUpdate?.let {
        if (given.getOnlyUpdate() != it) { result.add("${path}onlyUpdate ${given.getOnlyUpdate()} != ${it}") }
    }

    return result.joinToString("\n")
}