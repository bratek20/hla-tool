package com.github.bratek20.hla.generation.impl.core

import com.github.bratek20.hla.definitions.api.ModuleDefinition
import com.github.bratek20.hla.generation.api.GeneratedPattern
import com.github.bratek20.hla.generation.api.GeneratedSubmodule
import com.github.bratek20.hla.generation.api.PatternName
import com.github.bratek20.hla.generation.api.SubmoduleName
import com.github.bratek20.hla.generation.impl.core.api.ApiTypeFactory
import com.github.bratek20.hla.generation.impl.core.api.MacrosBuilder
import com.github.bratek20.hla.generation.impl.core.language.LanguageSupport
import com.github.bratek20.hla.velocity.api.VelocityFacade
import com.github.bratek20.hla.velocity.api.VelocityFileContentBuilder
import com.github.bratek20.utils.directory.api.File
import com.github.bratek20.utils.directory.api.FileContent

class ModuleGenerationContext(
    val domain: DomainContext,
    val velocity: VelocityFacade,
    val language: LanguageSupport,
    val onlyUpdate: Boolean,
    val onlyPatterns: List<String>
) {
    val module: ModuleDefinition
        get() = domain.module

    val apiTypeFactory: ApiTypeFactory
        get() = ApiTypeFactory(domain.queries, language.types())
}

interface ContentBuilderExtension{
    fun extend(builder: VelocityFileContentBuilder)
}

enum class GeneratorMode {
    START_AND_UPDATE,
    ONLY_START,
}

abstract class ModulePartGenerator {
    lateinit var c: ModuleGenerationContext
    lateinit var apiTypeFactory: ApiTypeFactory
    lateinit var velocityPath: String

    open fun velocityPathOverride(): String? {
        return null
    }

    open fun init(c: ModuleGenerationContext, velocityPath: String) {
        this.c = c
        this.apiTypeFactory = ApiTypeFactory(c.domain.queries, c.language.types())
        this.velocityPath = velocityPath
    }

    protected val module
        get() = c.module

    protected val modules
        get() = c.domain.queries

    protected val language
        get() = c.language

    protected val lang
        get() = c.language.base()

    protected fun contentBuilder(fileName: String): VelocityFileContentBuilder {
        val velocityPath = velocityPathOverride() ?: this.velocityPath
        val path = "templates/${c.language.name().name.lowercase()}/${velocityPath}/$fileName"

        val builder = c.velocity.contentBuilder(path)
            .put("moduleName", module.getName().value)

        c.language.contentBuilderExtensions().forEach { it.extend(builder) }

        return builder
    }
}

abstract class PatternGenerator
    : ModulePartGenerator()
{
    abstract fun generateFileContent(): FileContent?

    abstract fun patternName(): PatternName

    open fun mode(): GeneratorMode {
        return GeneratorMode.START_AND_UPDATE
    }

    fun generateFile(): File? {
        var content = generateFileContent() ?: return null
        if (mode() == GeneratorMode.START_AND_UPDATE) {
            val lines = listOf(
                "// DO NOT EDIT! Autogenerated by HLA tool",
                ""
            ) + content.lines
            content = FileContent(lines)
        }
        return File(
            name = patternName().name + "." + language.filesExtension(),
            content = content.toString()
        )
    }

    fun shouldSkip(): Boolean {
        if(c.onlyUpdate && mode() == GeneratorMode.ONLY_START) {
            return true
        }

        if(c.onlyPatterns.isNotEmpty() && !c.onlyPatterns.contains(patternName().name)) {
            return true
        }
        return false
    }
}

abstract class SubmoduleGenerator
    : ModulePartGenerator()
{
    private lateinit var patternGenerators: List<PatternGenerator>

    abstract fun submoduleName(): SubmoduleName

    override fun init(c: ModuleGenerationContext, velocityPath: String) {
        super.init(c, velocityPath)

        patternGenerators = getPatternGenerators()

        patternGenerators.forEach { it.init(c, velocityDirPath()) }
    }

    open fun velocityDirPath(): String {
        return ""
    }

    open fun shouldGenerateSubmodule(): Boolean {
        return true
    }

    abstract fun getPatternGenerators(): List<PatternGenerator>

    fun generateSubmodule(): GeneratedSubmodule? {
        if (!shouldGenerateSubmodule()) {
            return null
        }

        val files = mutableListOf<File>()
        patternGenerators.forEach { patternGenerator ->
            if (patternGenerator.shouldSkip()) {
                return@forEach
            }
            patternGenerator.generateFile()?.let { files.add(it) }
        }

        if (files.isEmpty()) {
            return null
        }

        return GeneratedSubmodule.create(
            name = submoduleName(),
            patterns = files.map {
                val patternName = PatternName.valueOf(it.getName().value.substringBeforeLast("."))
                GeneratedPattern.create(patternName, it)
            }
        )
    }

    //TODO-REF workaround to force macros generation
    fun generateMacros() {
        val macros = MacrosBuilder()
        macros.init(c, "macros")
        macros.generateFile()
    }
}